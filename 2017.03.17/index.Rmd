---
title       : "EMTF $p_T$ Regression"
subtitle    :
author      : Khristian Kotov
job         :
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      #
github:
  user: kkotov
  repo: emtfPtRegression
widgets     : [mathjax]     # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}
---

## Outline

--- &twocol

## Understanding ROC curves

[ROC curves](https://kkotov.github.io/emtfPtRegression/2017.02.10/#6) built with
[$1/p_T ^3$ spectrum](https://kkotov.github.io/emtfPtRegression/2017.03.03/#6)$^*$
and turn-ons for "myModel"$^{**}$ and EMTF ("baseline"):

```{r message = F, echo = F}
mode_inv <- 15
mode = c(0, 0, 12, 0, 10, 5, 14, 0, 9, 5, 13, 3, 11, 7, 15)
df <- read.csv(file="../../pt/SingleMu_Pt1To1000_FlatRandomOneOverPt.csv",header=T,sep=',')
d1 <- df[df[,"mode.0."]==mode[mode_inv], c( grep("\\.[0-1]\\.",colnames(df),invert=T) , grep(".0.",colnames(df),fixed=T) ) ]
d2 <- df[df[,"mode.1."]==mode[mode_inv], c( grep("\\.[0-1]\\.",colnames(df),invert=T) , grep(".1.",colnames(df),fixed=T) ) ]
colnames(d1) <- sub(".0.", "", colnames(d1),fixed=T)
colnames(d2) <- sub(".1.", "", colnames(d2),fixed=T)
d <- rbind(d1,d2)

require(ranger)
vars <- with(d,data.frame( 1/muPtGen,
                           2*atan(exp(-muEtaGen)),
                           pt,
                           mypt,
                           dPhi12,
                           dPhi13,
                           dPhi14,
                           dPhi23,
                           dPhi24,
                           dPhi34,
                           dTheta12,
                           dTheta13,
                           dTheta14,
                           dTheta23,
                           dTheta24,
                           dTheta34,
                           factor(clct1,levels=c(2,3,4,5,6,7,8,9,10)),
                           factor(clct2,levels=c(2,3,4,5,6,7,8,9,10)),
                           factor(clct3,levels=c(2,3,4,5,6,7,8,9,10)),
                           factor(clct4,levels=c(2,3,4,5,6,7,8,9,10)),
                           factor(fr1,levels=c(0,1)),
                           factor(fr2,levels=c(0,1)),
                           factor(fr3,levels=c(0,1)),
                           factor(fr4,levels=c(0,1))
                           )
            )
predictors <- c("dPhi12", "dPhi13", "dPhi14", "dPhi23", "dPhi24", "dPhi34", "dTheta12", "dTheta13", "dTheta14", "dTheta23", "dTheta24", "dTheta34", "clct1", "clct2", "clct3", "clct4", "fr1", "fr2", "fr3", "fr4")
colnames(vars) <- c("muPtGenInv", "theta", "ptTrg", "mypt", predictors )
predictors <- c("theta", predictors)

set.seed(1)

part <- sample(seq(nrow(vars)), as.integer(nrow(vars)*0.75), replace=F)
trainSet <- vars[part,]
testSet <- vars[-part,]
POI <- which(colnames(vars)=="muPtGenInv")

f <- as.formula(paste("muPtGenInv ~ ", paste(predictors, collapse= "+")))

invisible( capture.output( modelFit <- ranger(f, data=trainSet, importance="impurity") ) )


# Data below are generated from Andrew's /store/user/abrinke1/EMTF/Emulator/ntuples/ZeroBiasIsolatedBunch{0,1,2,3}
#  root ntuples translated into csv format with https://github.com/kkotov/emtfPtRegression/blob/master/root2csv.C
#  converter (check the heading comments inside for the use example)
# The cvs files were further skimmed with a bash batch job:
#  i=28; while [ $i -gt 0 ] ; do echo $i;  cat dump2.R | sed -e "s|PART|$i|g" > d$i"".R ; R CMD BATCH d$i.R ; rm -f .RData d$i.R d$i.Rout ; i=`expr $i - 1`; done
#  utilizing the https://github.com/kkotov/emtfPtRegression/blob/master/dump2.R script

for(f in paste("../../pt/s",c(0,1,2,3),".RData",sep='')) load(f)
zb <- s0
zb <- rbind(zb,s1)
zb <- rbind(zb,s2)
zb <- rbind(zb,s3)

testSetZB <- with(subset(zb,mode==15), data.frame(
                                 ptRef = ptEMTF,
                                 theta = theta,
                                 dPhi12 = phi1-phi2,
                                 dPhi13 = phi1-phi3,
                                 dPhi14 = phi1-phi4,
                                 dPhi23 = phi2-phi4,
                                 dPhi24 = phi2-phi4,
                                 dPhi34 = phi3-phi4,
                                 dTheta12 = theta1-theta2,
                                 dTheta13 = theta1-theta3,
                                 dTheta14 = theta1-theta4,
                                 dTheta23 = theta2-theta3,
                                 dTheta24 = theta2-theta4,
                                 dTheta34 = theta3-theta4,
                                 clct1 = factor(clct1,levels=c(2,3,4,5,6,7,8,9,10)),
                                 clct2 = factor(clct2,levels=c(2,3,4,5,6,7,8,9,10)),
                                 clct3 = factor(clct3,levels=c(2,3,4,5,6,7,8,9,10)),
                                 clct4 = factor(clct4,levels=c(2,3,4,5,6,7,8,9,10)),
                                 fr1 = factor(fr1,levels=c(0,1)),
                                 fr2 = factor(fr2,levels=c(0,1)),
                                 fr3 = factor(fr3,levels=c(0,1)),
                                 fr4 = factor(fr4,levels=c(0,1))
                                )
                 )

tszb <- testSetZB[-which(is.na(testSetZB$clct1) | is.na(testSetZB$clct2) | is.na(testSetZB$clct3) | is.na(testSetZB$clct4) ),]

invisible( capture.output( tszb$res <- 1/predict(modelFit,tszb)$predictions ) )

```

```{r message = F, echo = F}

require(ggplot2)
require("gridExtra")

source("../metrics.R")

## The code below crashes if ran it in slidify with full data set (that I shouldn't do anyway):
##  "Error in lazyLoadDBinsertValue(data, datafile, ascii, compress, envhook)"
pp <- preprocess(modelFit,
                 testSet, #vars, #
##                 rateShape = data.frame( true_pT = seq(1.01,1000.01,0.5), trigRate = 1/seq(1,1000,0.5)^3 ),
                 rateShapeBinned = c(1,1/seq(2,200,0.5)^3), # don't forget the underflow
                 binning = seq(2,200,0.5)
                )

## so if I'll ever need a bigger dataset, I first should run it interactively
 myTurnOn        <- pp$getMyTurnOn()
 refTurnOn       <- pp$getRefTurnOn()
 binning         <- pp$getBinning()
 rateShapeBinned <- pp$getRateShapeBinned()
 nBins           <- length(binning)
## save the results
# save(file="pp.RData",binning,rateShapeBinned,refTurnOn,myTurnOn)
# and then restore the results here from the file:
# load("pp.RData")
## but I don't do that because the testSet fits, and vars has been seen to model and shouldn't be used

```

*** =left

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}

tt <- turnOns(#pp,
              rateShapeBinned = rateShapeBinned,
              myModelTurnOn = myTurnOn,
              referenceTurnOn = refTurnOn,
              binning = binning,
              refScale = 1.43
      )
suppressWarnings( invisible( capture.output( 
    grid.arrange(tt[["20"]] + theme(legend.position="none"),
                 tt[["40"]] + theme(legend.position="none"),
                 tt[["60"]] + theme(legend.position="none"),
                 tt[["80"]] + theme(legend.position="none")
                )
) ) )

```

*** =right

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}

roc <- rocMetric(rateShapeBinned = rateShapeBinned,
                 myModelTurnOn = myTurnOn,
                 referenceTurnOn = refTurnOn,
                 binning = binning,
                 refScale = 1.43
       ) #pp

truePosPlot <- ggplot(data.frame(pT = c( binning, binning ),
                                 eff = c( roc[["myEff"]], roc[["refEff"]] ),
                                 model = factor( c(rep("myModel",nBins), rep("baseline",nBins) ) )
                      ),
                      aes(x = pT, y = eff, type = model, color = model)
                 ) +
                 geom_point(shape = 1, size = 0.1) +
                 theme(
                       title = element_text(size=20),
                       axis.title.x = element_text(size=20),
                       axis.text.x  = element_text(size=15)
                 ) +
                 labs(x = expression(paste(p[T] ^{true}," (GeV/c)")),
                      y = "true positive"
                 )

falsePosPlot <- ggplot(data.frame(pT = c( binning, binning ),
                                  eff = c( roc[["myFake"]], roc[["refFake"]] ),
                                  model = factor( c(rep("myModel",nBins), rep("baseline",nBins) ) )
                       ),
                       aes(x = pT, y = eff, type = model, color = model)
                ) +
                geom_point(shape = 1, size = 0.1) +
                theme(
                      title = element_text(size=20),
                      axis.title.x = element_text(size=20),
                      axis.text.x  = element_text(size=15)
                ) +
                labs(x = expression(paste(p[T] ^{true}," (GeV/c)")),
                     y = "false positive"
                ) +
                scale_y_log10()

suppressWarnings( invisible( capture.output( 
    grid.arrange(
                 arrangeGrob(truePosPlot  + xlim(0, 100) + theme(legend.position="none"),
                             falsePosPlot + xlim(0, 100) + theme(legend.position="none"),
                             ncol=2
                 ),
                 roc[["rocPlot"]] + xlim(0.75, 1) + labs(title=""),
                 nrow = 2
    )
) ) )

```

*** =fullwidth

[&nbsp;&nbsp;$^*$&nbsp;] any shape do well for qualitative comparison of the two models (i.e. relative behavior)

[$^{**}$] "myModel" is trained with $\Delta\phi \times 6$, $\Delta\theta \times 6$, $CLCT \times 4$, $FR \times 4$ (all full precision)

--- .class #id

## Scaling baseline turn-ons

Baseline model was originally scaled to have ~90% efficiency at threshold

Rescaling causes a small vertical and large horizontal shifts ([consequence of falling rate](https://kkotov.github.io/emtfPtRegression/2017.02.10/#6)):

```{r, fig.height=5., fig.width=10., fig.align = 'center', comment = NA, message = F, echo = F}

roc1.1 <- rocMetric(rateShapeBinned = rateShapeBinned,
                    myModelTurnOn = myTurnOn,
                    referenceTurnOn = refTurnOn,
                    binning = binning,
                    refScale = 1.1
          )

roc1.2 <- rocMetric(rateShapeBinned = rateShapeBinned,
                    myModelTurnOn = myTurnOn,
                    referenceTurnOn = refTurnOn,
                    binning = binning,
                    refScale = 1.2
          )

roc1.3 <- rocMetric(rateShapeBinned = rateShapeBinned,
                    myModelTurnOn = myTurnOn,
                    referenceTurnOn = refTurnOn,
                    binning = binning,
                    refScale = 1.3
          )

roc1.4 <- rocMetric(rateShapeBinned = rateShapeBinned,
                    myModelTurnOn = myTurnOn,
                    referenceTurnOn = refTurnOn,
                    binning = binning,
                    refScale = 1.4
          )

roc1.5 <- rocMetric(rateShapeBinned = rateShapeBinned,
                    myModelTurnOn = myTurnOn,
                    referenceTurnOn = refTurnOn,
                    binning = binning,
                    refScale = 1.5
          )

roc1.6 <- rocMetric(rateShapeBinned = rateShapeBinned,
                    myModelTurnOn = myTurnOn,
                    referenceTurnOn = refTurnOn,
                    binning = binning,
                    refScale = 1.6
          )

roc1.7 <- rocMetric(rateShapeBinned = rateShapeBinned,
                    myModelTurnOn = myTurnOn,
                    referenceTurnOn = refTurnOn,
                    binning = binning,
                    refScale = 1.7
          )

refROCdf <- data.frame( truePos  = roc1.1[["refEff"]],
                        falsePos = roc1.1[["refFake"]],
                        scale    = rep("1.1",nBins)
            )
refROCdf <- rbind( data.frame( truePos  = roc1.2[["refEff"]],
                               falsePos = roc1.2[["refFake"]],
                               scale    = rep("1.2",nBins)
                   ),
                   refROCdf
            )
refROCdf <- rbind( data.frame( truePos  = roc1.3[["refEff"]],
                               falsePos = roc1.3[["refFake"]],
                               scale    = rep("1.3",nBins)
                   ),
                   refROCdf
            )
refROCdf <- rbind( data.frame( truePos  = roc1.4[["refEff"]],
                               falsePos = roc1.4[["refFake"]],
                               scale    = rep("1.4",nBins)
                   ),
                   refROCdf
            )
refROCdf <- rbind( data.frame( truePos  = roc1.5[["refEff"]],
                               falsePos = roc1.5[["refFake"]],
                               scale    = rep("1.5",nBins)
                   ),
                   refROCdf
            )
refROCdf <- rbind( data.frame( truePos  = roc1.6[["refEff"]],
                               falsePos = roc1.6[["refFake"]],
                               scale    = rep("1.6",nBins)
                   ),
                   refROCdf
            )
refROCdf <- rbind( data.frame( truePos  = roc1.7[["refEff"]],
                               falsePos = roc1.7[["refFake"]],
                               scale    = rep("1.7",nBins)
                   ),
                   refROCdf
            )

refROCdf$scale <- factor(refROCdf$scale)

rocRangePlot <- ggplot(refROCdf, aes(x = truePos, y = falsePos, group = scale, colour = scale)) +
        geom_line() +
        geom_point(shape=1,size=0.1) +
        theme(
            title = element_text(size=20),
            axis.title.x = element_text(size=20),
            axis.text.x  = element_text(size=15),
            legend.position = c(.20, .70),
            legend.background = element_rect(fill = 'grey92', colour = 'black', size=0),
            legend.text=element_text(size=rel(1.5)),
            legend.title=element_text(size=rel(0.8), face="bold", hjust=0)
        ) +
        labs( x="true positive",
              y="false positive",
              title="ROC curves for the rescaled baseline"
        ) +
        scale_y_log10() +
        xlim(0.5,0.97)

suppressWarnings( invisible( capture.output( 
    rocRangePlot
) ) )

```

For a proper comparison I rescale it back multiplying baseline's thresholds by $1.43$

--- .class #id

## Efficiency-rate plot

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}

nBins   <- length(binning)
myRate  <- sapply(binning, function(x) sum(tszb$res>x) )
refRate <- sapply(binning, function(x) sum(tszb$ptRef>x) )

effRatePlot <- ggplot(data.frame(binning[1:100],
                                 eff = c(roc$myEff[1:100], roc$refEff[1:100]),
                                 rate = c(myRate[1:100], refRate[1:100]),
                                 model = c(rep("myModel",100), rep("baseline",100)) 
                                ),
                      aes(y = rate, x = eff, group = model, colour = model)
                     ) +
               geom_point(shape=1,size=0.1) + 
               geom_line() + 
               theme(
                    title = element_text(size=20),
                    axis.title.x = element_text(size=20),
                    axis.text.x  = element_text(size=15),
                    legend.position = c(.20, .80),
                    legend.background = element_rect(fill = 'grey92', colour = 'black', size=0),
                    legend.text = element_text(size=rel(1.5)),
                    legend.title = element_text(size=rel(0.8), face="bold", hjust=0)
               ) +
               labs(x = "efficiency",
                    y = "rate",
                    title = "Efficiency-rate curve"
               )

suppressWarnings( invisible( capture.output(
  effRatePlot + xlim(0.75, 1) # + scale_y_log10()
) ) )

```


--- &twocol

## Minimal predictor's compression

```{r message = F, echo = F}
source("../utils.R")

vars2 <- with(vars,data.frame( muPtGenInv,
                           sat(theta,5),
                           ptTrg,
                           abs(sat(dPhi12,7)),
                           abs(sat(dPhi23,5)),
                           abs(sat(dPhi34,5)),
                           as.factor(ifelse(dPhi23*dPhi12>=0,0,1)),
                           as.factor(ifelse(dPhi34*dPhi12>=0,0,1)),
                           abs(sat(dPhi12,5)) + ifelse(dPhi23*dPhi12>=0,1,-1)*abs(sat(dPhi23,5)), # analogous to dPhi13
                           abs(sat(dPhi12,5)) + ifelse(dPhi23*dPhi12>=0,1,-1)*abs(sat(dPhi23,5)) + ifelse(dPhi34*dPhi12>=0,1,-1)*abs(sat(dPhi34,5)),
                           abs(sat(dPhi23,5)) + ifelse(dPhi34*dPhi12>=0,1,-1)*abs(sat(dPhi34,5)), # analogous to dPhi24
                           abs(sat(dTheta12,2)),
                           abs(sat(dTheta23,2)),
                           abs(sat(dTheta34,2)),
                           as.factor(ifelse(dTheta23*dTheta12>=0,0,1)),
                           as.factor(ifelse(dTheta34*dTheta12>=0,0,1)),
                           abs(sat(dTheta12,2)) + ifelse(dTheta23*dTheta12>=0,1,-1)*abs(sat(dTheta23,2)), # analogous to dTheta13
                           abs(sat(dTheta12,2)) + ifelse(dTheta23*dTheta12>=0,1,-1)*abs(sat(dTheta23,2)) + ifelse(dTheta34*dTheta12>=0,1,-1)*abs(sat(dTheta34,2)),
                           abs(sat(dTheta23,2)) + ifelse(dTheta34*dTheta12>=0,1,-1)*abs(sat(dTheta34,2)), # analogous to dTheta24
#                           c(0,0,0,0,0,0,1,0,2,0,3,0,0,0,0,0)[bitwAnd(as.integer(as.character(clct1)),0xF)+1],
#                           c(0,0,0,0,0,0,1,0,2,0,3,0,0,0,0,0)[bitwAnd(as.integer(as.character(clct2)),0xF)+1],
#                           c(0,0,0,0,0,0,1,0,2,0,3,0,0,0,0,0)[bitwAnd(as.integer(as.character(clct3)),0xF)+1],
#                           c(0,0,0,0,0,0,1,0,2,0,3,0,0,0,0,0)[bitwAnd(as.integer(as.character(clct4)),0xF)+1],
                           clct1,
                           clct2,
                           clct3,
                           clct4,
                           fr1,
                           fr2,
                           fr3,
                           fr4
                             )
         )

predictors2 <- c("dPhi12", "dPhi23", "dPhi34", "sPhi123", "sPhi134", "dPhi13", "dPhi14", "dPhi24", "dTheta12", "dTheta23", "dTheta34", "sTheta123", "sTheta134", "dTheta13", "dTheta14", "dTheta24", "clct1", "clct2", "clct3", "clct4", "fr1", "fr2", "fr3", "fr4")
colnames(vars2) <- c("muPtGenInv", "theta", "ptTrg", predictors2 )
predictors2 <- c("theta", predictors2)

set.seed(1)

#part <- sample(seq(nrow(vars)), as.integer(nrow(vars)*0.75), replace=F)
trainSet2 <- vars2[part,]
testSet2 <- vars2[-part,]

f2 <- as.formula(paste("muPtGenInv ~ ", paste(predictors2, collapse= "+")))

invisible( capture.output( modelFit2 <- ranger(f2, data=trainSet2, importance="impurity") ) )
```

*** =left

```{r message = F, echo = F}
pp2 <- preprocess( modelFit = modelFit2,
                   testSet = testSet2,
                   rateShapeBinned,
                   binning
                 )
```

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}
lCompTurnOn <- pp2$getMyTurnOn()

roc2 <- rocMetric( rateShapeBinned = rateShapeBinned,
                   myModelTurnOn = lCompTurnOn,
                   referenceTurnOn = myTurnOn,
                   binning = binning,
                   refScale = 1.43
        )
myModelROCdf <- data.frame( truePos  = roc2[["refEff"]],
                            falsePos = roc2[["refFake"]],
                            model    = rep("uncompressed",nBins)
                )
lCompROCdf   <- data.frame( truePos  = roc2[["myEff"]],
                            falsePos = roc2[["myFake"]],
                            model    = rep("compressed",nBins)
                )
start <- sum(rateShapeBinned==0) + 1
myModelROCdf   <- myModelROCdf[start:nBins,]
lCompROCdf     <- lCompROCdf[start:nBins,]

roc2DF <- rbind(myModelROCdf,lCompROCdf)
roc2DF$model <- factor(roc2DF$model)

roc2Plot <- ggplot(roc2DF, aes(x = truePos, y = falsePos, group = model, colour = model)) +
#        geom_errorbar(aes(ymin=eff-se, ymax=eff+se), width=.1) +
        geom_line() +
        geom_point(shape=1,size=0.1) +
        theme(
            title = element_text(size=20),
            axis.title.x = element_text(size=20),
            axis.text.x  = element_text(size=15),
            legend.position = c(.20, .80),
            legend.background = element_rect(fill = 'grey92', colour = 'black', size=0),
            legend.text=element_text(size=rel(1.5)),
            legend.title=element_text(size=rel(0.8), face="bold", hjust=0)
        ) +
        labs( x="true positive",
              y="false positive",
              title="ROC curves for myModels"
        ) + scale_y_log10()

suppressWarnings( invisible( capture.output( 
  roc2Plot + xlim(0.75, 0.98)
) ) )

```

*** =right

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}
barplot( modelFit2$variable.importance, horiz=T, col='red', xlab='Delta MSE', las=2 )
```

*** =fullwidth

--- .class #id

## Summary

One has to be careful comparing models using ROC curves!
