---
title       : "EMTF $p_T$ Regression"
subtitle    :
author      : Khristian Kotov
job         :
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      #
github:
  user: kkotov
  repo: emtfPtRegression
widgets     : [mathjax]     # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}
---

## Outline

--- &twocol

## Measured rate properties

```{r message = F, echo = F}
mode_inv <- 15
mode = c(0, 0, 12, 0, 10, 5, 14, 0, 9, 5, 13, 3, 11, 7, 15)
df <- read.csv(file="../../pt/SingleMu_Pt1To1000_FlatRandomOneOverPt.csv",header=T,sep=',')
d1 <- df[df[,"mode.0."]==mode[mode_inv], c( grep("\\.[0-1]\\.",colnames(df),invert=T) , grep(".0.",colnames(df),fixed=T) ) ]
d2 <- df[df[,"mode.1."]==mode[mode_inv], c( grep("\\.[0-1]\\.",colnames(df),invert=T) , grep(".1.",colnames(df),fixed=T) ) ]
colnames(d1) <- sub(".0.", "", colnames(d1),fixed=T)
colnames(d2) <- sub(".1.", "", colnames(d2),fixed=T)
d <- rbind(d1,d2)

source("../metrics.R")
binning <- seq(0,100,2)
nBins   <- length(binning)
slimDF  <- with(d, data.frame(true_pT = muPtGen, response_pT = pt) )
slimDF$trueBin <- sapply(slimDF$true_pT, findBin, binning)
pSpec   <- aggregate(slimDF, by=list(bin=slimDF$trueBin), function(x) x )
norms   <- sapply(pSpec$response_pT,length)
counts  <- t(sapply(pSpec$response_pT,function(x) sapply(binning,function(y) sum(unlist(x)>y) )))
turnOn  <- counts/norms

for(f in paste("../../pt/s",c(0,1,2,3),".RData",sep='')) load(f)
zb <- s0
zb <- rbind(zb,s1)
zb <- rbind(zb,s2)
zb <- rbind(zb,s3)

ptMes <- zb$ptEMTF

#dfXY <- data.frame( x=runif(1e8,1,1000), y=runif(1e8) )
#pt <- dfXY[ 1/dfXY$x^2 > dfXY$y,"x"]
#rm(dfXY)
#qqplot(runif(30000,0.001,1)^-1,pt) # for the power spectrum this is much more efficient generator
## also check this out:
# pt <- dfXY[ 1/dfXY$x^4 > dfXY$y,"x"]
# qqplot(runif(30000,0.00001,1)^(-1/3),pt)
# so the scale-formula is b = 1/(a+1), e.g. a = -4 => b = -1/3, a = -2 => b = -1

pt2.7 <- runif(30000000,0.00001,1)^(-1/1.7)
rate2.7 <- sapply(binning[2:nBins], function(x) sum(pt2.7 > x) )

require(ggplot2)
```

*** =left

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}

qqPlot <- ggplot() +
        geom_freqpoly( data=data.frame(pT=pt2.7),
                        breaks=seq(2,257,2),
#                        alpha = 0.2,
                        position = "identity",
                        aes( x = pT,
                             y = (..count..)/sum(..count..),
                             colour = "r",
                             fill = "r"
                        )
                      ) +
        geom_freqpoly( data=data.frame(pT=ptMes),
                        breaks=seq(2,257,2),
#                        alpha = 0.2,
                        position = "identity",
                        aes( x = pT,
                             y = (..count..)/sum(..count..),
                             colour = "b",
                             fill = "b"
                        )
                      ) +
        theme(
            title = element_text(size=20),
            axis.title.x = element_text(size=15),
            axis.text.x  = element_text(size=20),
            legend.position = c(.6, .7),
            legend.background = element_rect(fill = 'grey92', colour = 'black', size=0),
            legend.text=element_text(size=rel(1.5)),
            legend.title=element_text(size=rel(0.8), face="bold", hjust=0)
        ) +
        labs( x=expression(paste(p[T], " (GeV/c)")),
              y="density",
              title="Rate"
        ) +
        scale_colour_manual(name = "", values=c("r" = "red", "b"="blue"), labels=c("b"="EMTF", "r"=expression(1/p[T] ^2.7))) +
        scale_fill_manual(name = "",   values=c("r" = "red", "b"="blue"), labels=c("b"="EMTF", "r"=expression(1/p[T] ^2.7))) +
        scale_y_log10()

qqPlot
```

*** =right

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}
#qqplot(pt0.45,ptMes)
# ggplot2 equivalent of the build-in above:

qqPlot <- ggplot( data.frame(qqplot(x=ptMes, y=pt2.7, plot.it=FALSE)) ) +
        geom_point(aes(x=x, y=y)) +
        theme(
            title = element_text(size=20),
            axis.title.x = element_text(size=20),
            axis.text.x  = element_text(size=20),
            axis.title.y = element_text(size=20),
            axis.text.y  = element_text(size=0)
        ) +
        labs( y=expression(paste(1/p[T] ^2.7, " spectrum")),
              x=expression(paste("measured ", p[T], " rate (Gev/c)")),
              title="Distribution similarity (q-q)"
        ) #+ scale_x_log10()

qqPlot
```

*** =fullwidth

Clearly seen are two components meeting at $\sim$100 GeV/$c$ (and the EMTF pT saturation)

Since all of the thresholds of interest are < 100 GeV/$c$ let's zoom in to the first component

--- &twocol

## Low $p_T$ part of the measured spectrum

Simple power law is a rather crude approximation, exponent + power law works better:

```{r message = F, echo = F}
# let's fit a binned likelihood

binning <- seq(2,80,1)
rateThr <- sapply(binning, function(x) sum(ptMes > x) )
rateBin <- sapply(1:(length(binning)-1), function(x) sum(ptMes > binning[x] & ptMes < binning[x+1]) )

binLikelihood <- function(par, rate, mode) {
    norm1     <- par[1]
    powerLaw1 <- par[2]
    norm2     <- par[3]
    powerLaw2 <- par[4]
    shift     <- par[5]
    if(mode == "aboveThr")
        estRate   <- sapply(binning,function(x) rate[1]*(norm1/exp(x*powerLaw1) + norm2/((x+shift)^powerLaw2)))
    else
        estRate   <- sapply(binning[1:(length(binning)-1)],function(x) rate[1]*(norm1/exp(x*powerLaw1) + norm2/((x+shift)^powerLaw2)))
    sum( (rate - estRate)^2 )
}

#invisible( capture.output( ) )
suppressWarnings( fitAbove <- nlm(binLikelihood, c(1,2,1,1,10), rate = rateThr, mode="aboveThr", hessian=T) )
suppressWarnings( fitDiff  <- nlm(binLikelihood, c(1.8,1.2,17,3.1,3), rate = rateBin, mode="diff", hessian=T) )
#solve(fitMes$hessian) # to get covariance matrix if needed

norm1_d     <- fitDiff$estimate[1]
powerLaw1_d <- fitDiff$estimate[2]
norm2_d     <- fitDiff$estimate[3]
powerLaw2_d <- fitDiff$estimate[4]
shift_d     <- fitDiff$estimate[5]
approxRateDiff  <- sapply(binning[1:(length(binning)-1)],function(x) rateBin[1]*(norm1_d/exp(x*powerLaw1_d) + norm2_d/((x+shift_d)^powerLaw2_d)))

norm1_a     <- fitAbove$estimate[1]
powerLaw1_a <- fitAbove$estimate[2]
norm2_a     <- fitAbove$estimate[3]
powerLaw2_a <- fitAbove$estimate[4]
shift_a     <- fitAbove$estimate[5]
approxRateAbove <- sapply(binning,function(x) rateThr[1]*(norm1_a/exp(x*powerLaw1_a) + norm2_a/((x+shift_a)^powerLaw2_a)))

rateOrig_d <- data.frame(pT = binning[1:(length(binning)-1)], cnt = rateBin) 
rateFit_d  <- data.frame(pT = binning[1:(length(binning)-1)], cnt = approxRateDiff)

rateOrig_a <- data.frame(pT = binning, cnt = rateThr) 
rateFit_a  <- data.frame(pT = binning, cnt = approxRateAbove)
```

```{r message = F, echo = F}
makeRRplot <- function(rateOrig, rateFit, norm1, powerLaw1, norm2, poserLaw2, shift, title) {
        ggplot() +
        geom_line( data = rateOrig,
                   aes( x = pT,
                        y = cnt,
                        colour = "r",
                        fill = "r"
                      )
                 ) +
        geom_line( data = rateFit,
                   aes( x = pT,
                        y = cnt,
                        colour = "b",
                        fill = "b"
                   )
                 ) +
        labs( x=expression(paste(p[T], " (GeV/c)")),
              y="conuts",
              title=title
        ) +
        theme(
            title = element_text(size=20),
            axis.title.x = element_text(size=15),
            axis.text.x  = element_text(size=20),
            legend.position = c(.50, .85),
            legend.background = element_rect(fill = 'grey92', colour = 'black', size=0),
            legend.text=element_text(size=rel(1.5)),
            legend.title=element_text(size=rel(0.8), face="bold", hjust=0)
        ) +
        scale_colour_manual(name = "",
                            values = c("r" = "red", "b"="blue"),
                            labels = c("r"="EMTF",
                                       "b"=bquote(.(signif(norm1,2)) ~ "/" ~ e^ ~ {.(signif(powerLaw1,2)) ~ p[T]} ~ "+" ~ .(signif(norm2,2)) ~ "/(" ~ p[T] ~ "+" ~ .(signif(shift,2)) ~ ")"^.(signif(powerLaw2,2)) )
                                      )
                           ) +
        scale_fill_manual(name = "",
                          values = c("r" = "red", "b"="blue"),
                          labels = c("r"="EMTF",
                                     "b"=bquote(.(signif(norm1,2)) ~ "/" ~ e^ ~ {.(signif(powerLaw1,2)) ~ p[T]} ~ "+" ~ .(signif(norm2,2)) ~ "/(" ~ p[T] ~ "+" ~ .(signif(shift,2)) ~ ")"^.(signif(powerLaw2,2)) )
                                    )
                         ) +
        scale_y_log10()
}
```

*** =left

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}
makeRRplot(rateOrig_d, rateFit_d, norm1_d, powerLaw1_d, norm2_d, poserLaw2_d, shift_d, "Rate")
```

*** =right

```{r, fig.height=5., fig.width=5., fig.align = 'center', comment = NA, message = F, echo = F}
#qqPlot <- ggplot( data.frame(x=ptMesCut80), aes(sample=x)) +
#         stat_qq( distribution = function(x,norm1,powerLaw1,norm2,powerLaw2,shift) norm1/exp(x*powerLaw1) + norm2/((x+shift)^powerLaw2),
#                  dparams = list("norm1" = norm1, "powerLaw1" = powerLaw1, "powerLaw2" = powerLaw2, "shift" = shift)
#         )
#qqPlot

makeRRplot(rateOrig_a, rateFit_a, norm1_a, powerLaw1_a, norm2_a, poserLaw2_a, shift_a, "Integrated rate above threshold")
```

*** =fullwidth


qwe The $1/p_T^{2.4}$, although, not ideal, seems to be a good 

--- .class #id

## Low $p_T$ part of the measured spectrum


